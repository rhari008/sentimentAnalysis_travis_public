'use strict';

var cookieParser = require('cookie-parser');
var ws = require('ws');

var buildProxyUri = require('../backend-request/options').buildProxyUri;
var getHeaders = require('../backend-request/headers').getHeaders;
var isAuthorized = require('../middleware/authorization-handler');
var loginProvider = require('../middleware/login-provider');
var pathRewriter = require('../middleware/path-rewriter');
var agents = require('../backend-request/agents');

var GENERAL_WS_ERROR_CODE = 1008;

module.exports = ConnectionHandler;

function ConnectionHandler(loggingContext) {
  this.logger = loggingContext.getLogger('/approuter/WebSockets');
  this.tracer = loggingContext.getTracer();
}

ConnectionHandler.prototype.createConnection = function (incoming, approuter) {
  var options = {
    memoryStore: approuter.get('memoryStore'),
    sessionCookieKey: approuter.get('sessionCookieKey'),
    cookieName: approuter.get('cookieName')
  };
  this.tracer.debug('[websockets] connection to approuter established');
  this.defaultSessionTimeout = options.memoryStore.getDefaultSessionTimeout();

  var req = incoming.upgradeReq;
  var targetURL;
  try {
    targetURL = pathRewriter(req);
  } catch (exc) {
    this.tracer.debug('[websockets] path rewriting failed with', exc);
    return rejectConnection.call(this, incoming, 'Internal server error');
  }
  if (!targetURL || !targetURL.destination || !targetURL.href || targetURL.href.charAt(0) === '/') {
    this.tracer.debug('[websockets] not able to match the web socket request to any configured backend');
    return rejectConnection.call(this, incoming, 'Not Found');
  }
  req.internalUrl = targetURL;

  var self = this;
  var cookieParserFunction = cookieParser(options.sessionCookieKey);
  this.memoryStore = options.memoryStore;

  cookieParserFunction(req, null, function () {
    self.sessionID = req.signedCookies[options.cookieName];
    options.memoryStore.get(self.sessionID, function (err, sess) {
      req.session = sess;
      if (loginProvider.isLoginRequired(req) || !isAuthorized(req)) {
        return rejectConnection.call(self, incoming, 'Permission denied');
      }
      connectToBackend.call(self, targetURL, incoming);
    });
  });
};

function resetSocketTimeout() {
  if (this.timer) {
    clearTimeout(this.timer);
  }
  this.timer = setTimeout(this.socketTimeoutCb, this.defaultSessionTimeout * 60 * 1000);
}

function connectToBackend(targetUrl, incoming) {
  var url = targetUrl.href;
  var req = incoming.upgradeReq;

  var outgoing;
  try {
    this.tracer.debug('[websockets] connecting to backend server:', url);
    outgoing = new ws(url, {
      agent: agents.get(targetUrl.protocol, buildProxyUri(targetUrl.destination)),
      headers: getHeaders(req,
        req.session && req.session.user.token && req.session.user.token.accessToken,
        targetUrl.destination)
    });
  } catch (err) {
    this.logger.error('[websockets]', err.message);
    return rejectConnection.call(this, incoming, 'Connecting to server failed');
  }

  this.incoming = incoming;
  this.outgoing = outgoing;
  this.outgoingIsOpened = false;
  this.queue = [];

  outgoing.on('open', handleOutgoingOpen.bind(this));
  outgoing.on('error', handleOutgoingError.bind(this));
  incoming.on('message', handleIncomingMessage.bind(this));
  outgoing.on('message', handleOutgoingMessage.bind(this));
  incoming.on('close', handleIncomingClose.bind(this));
  outgoing.on('close', handleOutgoingClose.bind(this));
  incoming.on('ping', resetSessionTimeout.bind(this));
  incoming.on('pong', handleIncomingPong.bind(this));
  outgoing.on('pong', incoming.pong.bind(incoming));
}

function resetSessionTimeout() {
  this.memoryStore.resetSessionTimer(this.sessionID);
  resetSocketTimeout.call(this);
}

function handleIncomingPong(data, options) {
  resetSessionTimeout.call(this);
  this.outgoing.pong(data, options);
}

function socketTimeoutCb() {
  if (this.incoming) {
    this.incoming.close(GENERAL_WS_ERROR_CODE, 'Session timeout occured!');
  }
}

function handleOutgoingOpen() {
  this.tracer.debug('[websockets] outgoing connection opened');
  this.outgoingIsOpened = true;
  this.socketTimeoutCb = socketTimeoutCb.bind(this);
  resetSocketTimeout.call(this);
  var msg = this.queue.shift();
  while (msg) {
    sendMessage.call(this, this.outgoing, msg);
    msg = this.queue.shift();
  }
}

function handleOutgoingError(err) {
  this.logger.error('[websockets] outgoing connection error occured: %s', err.message);
  rejectConnection.call(this, this.incoming, err.message);
}

function sendMessage(socket, msg) {
  if (!socket) {
    return this.logger.error('[websockets] cannot send message! Socket closed!');
  }
  resetSessionTimeout.call(this);
  var self = this;
  socket.send(msg, function ack(err) {
    if (err) {
      self.logger.error('[websockets] error during socket.send', err);
    }
  });
}

function handleIncomingMessage(msg) {
  if (this.outgoingIsOpened) {
    sendMessage.call(this, this.outgoing, msg);
  } else {
    this.queue.push(msg);
  }
}

function handleOutgoingMessage(msg) {
  sendMessage.call(this, this.incoming, msg);
}

function handleIncomingClose(code, message) {
  this.incoming = null;
  code = code || 1000; // 1000 - normal close from client
  message = message || 'client connection closed';
  this.tracer.debug('[websockets] closing outgoing socket!');
  rejectConnection.call(this, this.outgoing, message, code);
}

function handleOutgoingClose(code, message) {
  this.outgoing = null;
  code = code || 1001; // 1001 - close from server
  message = message || 'target server connection closed';
  this.tracer.debug('[websockets] closing incoming socket!');
  rejectConnection.call(this, this.incoming, message, code);
}

function rejectConnection(socket, message, code) {
  this.timer && clearTimeout(this.timer);
  if (socket) {
    var closingWSCode = isValidCode(code) ? code : GENERAL_WS_ERROR_CODE;
    this.tracer.debug('[websockets] closing connection for reason:', message, 'status code:', closingWSCode);
    socket.close(closingWSCode, message);
  }
}

function isValidCode(code) {
  // the codes are defined in rfc6455#section-7.4
  return !!code && ((code >= 1000 && code <= 1011 && code !== 1004 && code !== 1005 && code !== 1006) ||
    (code >= 3000 && code <= 4999));
}
