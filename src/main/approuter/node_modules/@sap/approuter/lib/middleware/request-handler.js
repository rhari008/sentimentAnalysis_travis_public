'use strict';

var VError = require('verror').VError;

var backendOptions = require('../backend-request/options');
var cookieHandler = require('../backend-response/cookie-handler');
var traceUtil = require('../utils/trace-util');
var requestTraceEnabled = traceUtil.requestTraceEnabled;

module.exports = function requestHandler(req, res, next) {
  if (!req.internalUrl) {
    return next();
  }

  var routerConfig = req.routerConfig;
  if (routerConfig.getToken) {
    var startTime = Date.now();
    routerConfig.getToken(req, function(err, accessToken) {
      if (err) { return next(err); }
      traceGetToken(req.loggingContext.getTracer(), accessToken, startTime);
      callBackend(req, res, accessToken, next);
    });
  } else {
    callBackend(req, res, null, next);
  }
};

function traceGetToken(tracer, accessToken, startTime) {
  var time = Date.now() - startTime;
  if (accessToken) {
    tracer.debug('getToken returned a custom access token in %d ms', time);
  } else {
    tracer.debug('getToken completed in %d ms without a custom access token', time);
  }
}

function callBackend(req, res, accessToken, next) {
  var url = req.internalUrl;
  var backendRequest = backendOptions.getRequest(req, accessToken);
  var requestStats = {};
  if (requestTraceEnabled) {
    requestStats.requestStart = Date.now();
  }
  var clientReq = backendRequest();

  if (url.destination.timeout) {
    clientReq.setTimeout(url.destination.timeout);
  }
  clientReq.on('timeout', function () {
    clientReq.abort();
    returnGateWayError(504, next, new VError('Request to %s failed with a timeout', url.href));
  });
  clientReq.on('error', function (err) {
    returnGateWayError(502, next, new VError(err, 'error while forwarding request to %s', url.href));
  });
  req.on('error', function (err) {
    returnGateWayError(502, next, new VError(err, 'error in reading from incoming request while forwarding to %s', url.href));
  });
  req.pipe(clientReq);

  if (requestTraceEnabled) {
    clientReq.on('socket', function (socket) {
      requestStats.currentBytesRead = socket.bytesRead;
    });
  }
  clientReq.on('response', function(clientRes) {
    var requests = {
      incomingRequest: req,
      incomingResponse: res,
      outgoingRequest: clientReq,
      outgoingResponse: clientRes
    };
    onResponse(requests, requestStats, next);
  });
}

function onResponse(requests, requestStats, next) {
  var incomingRequest = requests.incomingRequest;
  var incomingResponse = requests.incomingResponse;
  var outgoingRequest = requests.outgoingRequest;
  var outgoingResponse = requests.outgoingResponse;
  var tracer = incomingRequest.loggingContext.getTracer();

  traceUtil.traceBackendResponse(tracer, outgoingResponse);
  var backendCookies = cookieHandler.processCookies(outgoingResponse.headers['set-cookie']);
  if (incomingRequest.session && backendCookies.sessionCookies.length > 0) {
    cookieHandler.storeSessionCookies(backendCookies.sessionCookies, incomingRequest);
  }
  for (var headerName in outgoingResponse.headers) {
    if (headerName === 'set-cookie') {
      backendCookies.nonSessionCookies.length && incomingResponse.setHeader(headerName, backendCookies.nonSessionCookies);
    } else {
      incomingResponse.setHeader(headerName, outgoingResponse.headers[headerName]);
    }
  }
  incomingResponse.statusCode = outgoingResponse.statusCode;
  incomingResponse.statusMessage = outgoingResponse.statusMessage;
  var url = incomingRequest.internalUrl;
  if (url.destination.timeout) {
    outgoingResponse.setTimeout(url.destination.timeout);
  }
  outgoingResponse.on('timeout', function() {
    outgoingRequest.abort();
    returnGateWayError(504, next, new VError('Response from %s failed with a timeout', url.href));
  });
  outgoingResponse.on('error', function(err) {
    returnGateWayError(502, next, new VError(err, 'error while reading from incoming response (backend request to %s)', url.href));
  });
  if (requestTraceEnabled) {
    outgoingResponse.on('end', function () {
      var logger = incomingRequest.loggingContext.getLogger('/request/outgoing');
      var bytesRead = outgoingResponse.connection.bytesRead - requestStats.currentBytesRead;
      logger.info('%s to %s took %d ms to respond with status code %d and %d bytes',
        incomingRequest.method, url.href, Date.now() - requestStats.requestStart, outgoingResponse.statusCode, bytesRead);
    });
  }
  incomingResponse.on('error', function(err) {
    returnGateWayError(502, next, new VError(err, 'error while sending data to outgoing response (backend request to %s)', url.href));
  });
  traceUtil.traceOutgoingResponse(tracer, incomingResponse);
  outgoingResponse.pipe(incomingResponse);
}

function returnGateWayError(status, next, err) {
  err.status = status;
  next(err);
}
