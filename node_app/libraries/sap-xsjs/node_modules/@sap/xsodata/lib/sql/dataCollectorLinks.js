'use strict';

//Include
var dataCollector = require('./dataCollector');

exports.movePayloadFromSegmentToSelectStm = function (context, asyncDone) {
	context.logger.silly('dataCollectorLinks', 'movePayloadFromSegmentToSelectStm');
	//get dbSegment to be updated, for inserting the payload
	var dbSeg = context.oData.links.toBeUpdated;
	var stm = dbSeg.sql.stmContainer.insertTmp;

	if (!stm) {
		return asyncDone(new Error("An error occurred."), context);
	}

	var max = dbSeg._recordNV.length;
	var i;
	for (i = 0; i < max; i++) {
		var nv = dbSeg._recordNV[i];
		stm.setValue(nv.name, nv.value);
	}
	return asyncDone(null, context);
};

exports.movePayloadFromMNSegmentToSelectStm = function (context, asyncDone) {
	//get dbSegment for inserting the payload
	var dbSeg = context.oData.dbSegmentLast;
	var stm = dbSeg.sql.stmContainer.insertTmp;
	if (!stm) {
		return asyncDone(new Error("An error occurred."), context);
	}

	var over = dbSeg.getOver();
	// property names are read from association's 'over' , e.g. ID_A, ID_B
	// values are taken from the corresponding DBSegments' key values
	stm.setValue(over.principal[0], context.oData.dbSegment._KeyValues[0].value);
	stm.setValue(over.dependent[0], context.oData.dbSegmentLast._KeyValues[0].value);

	return asyncDone(null, context);
};

exports.createTmpTable = function (context, asyncDone) {
	var dbSeg = context.oData.links.toBeUpdated;
	var stms = [
		dbSeg.sql.stmContainer.createTmpOld,
		dbSeg.sql.stmContainer.createTmp,
		dbSeg.sql.stmContainer.createPrincipal,
		dbSeg.sql.stmContainer.createDependent
	];

	return dataCollector.execParallelNoResult(stms, context, asyncDone);
};

exports.createTmpTableMN = function (context, asyncDone) {
	var dbSeg = context.oData.dbSegmentLast;
	var stms = [
		dbSeg.sql.stmContainer.createTmp,
		dbSeg.sql.stmContainer.createPrincipal,
		dbSeg.sql.stmContainer.createDependent
	];
	return dataCollector.execParallelNoResult(stms, context, asyncDone);
};

exports.insertOldDataToOldTable = function (context, asyncDone) {
	var dbSeg = context.oData.links.toBeUpdated;

	return dataCollector.execParallelNoResultwithParam([dbSeg.sql.stmContainer.insertTmpOld], context,
		dataCollector.getAffectedRowsValidator(1, asyncDone),
		/**
		 * true ->  provide affectedRows parameter.
		 */
		true);
};

/**
 * insert corresponding data to the temp principal|dependent tables
 * */
exports.insertOldDataToPrincipalDependentTables = function (context, asyncDone) {
	var dbSeg = context.oData.links.toBeUpdated;
	var stms = [
		dbSeg.sql.stmContainer.insertPrincipal,
		dbSeg.sql.stmContainer.insertDependent
	];

	return dataCollector.execParallelNoResultwithParam(stms, context, asyncDone);
};

exports.insertPayloadIntoTempTable = function (context, asyncDone) {
	var dbSeg = context.oData.links.toBeUpdated;

	context.logger.silly('dataCollectorLinks', 'insertPayloadIntoTempTable');

	return dataCollector.execParallelNoResultwithParam([dbSeg.sql.stmContainer.insertTmp], context,
		dataCollector.getAffectedRowsValidator(1, asyncDone),
		/**
		 * true ->  provide affectedRows parameter.
		 */
		true);
};

exports.insertTmpTableToRealTable = function (context, asyncDone) {
	context.logger.silly('dataCollectorLinks', 'insertTmpTableToRealTable');

	var dbSeg = context.oData.links.toBeUpdated;

	return dataCollector.execParallelNoResultwithParam([dbSeg.sql.stmContainer.updateReal], context,
		dataCollector.getAffectedRowsValidator(1, asyncDone),
		/**
		 * true ->  provide affectedRows parameter.
		 */
		true);
};

exports.commit = function (context, asyncDone) {
	if (context.batchContext) {
		//When running in batch the commit is performed by the batch executor
		return asyncDone(null, context);
	}

	var client = context.db.client;
	client.commit(function (err) {
		if (err) {
			context.logger.info('SQL Exec', 'Commit Error: \n' + err);
			return asyncDone(err, context);
		}
		return asyncDone(null, context);
	});
};

/**
 * Executes truncation of temporary created tables for MxN tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.truncateTempTablesMN = function (context, asyncDone) {
	var statements;
	context.logger.silly('dataCollectorLinks', 'truncateTempTablesMN');

	statements = [
		context.sql.container.createTmpTruncate,
		context.sql.container.createPrincipalTruncate,
		context.sql.container.createDependentTruncate
	];

	return dataCollector.execTempTableStatements(statements, context, asyncDone);
};

/**
 * Executes deletion of temporary created MxN tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.dropTempTablesMN = function (context, asyncDone) {
	var statements;
	context.logger.silly('dataCollectorLinks', 'dropTempTablesMN');

	statements = [
		context.sql.container.createTmpDrop,
		context.sql.container.createPrincipalDrop,
		context.sql.container.createDependentDrop
	];

	return dataCollector.execTempTableStatements(statements, context, asyncDone);
};

/**
 * Executes truncation of temporary created tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.truncateTempTables = function (context, asyncDone) {
	var statements;
	context.logger.silly('dataCollectorLinks', 'truncateTempTables');

	// Special hack for $batch.
	// In batch we do not know at this place if we are in m2n mode or not.
	// If 'createTmpOldTruncate' property exists than we are in m2n mode
	if (!context.sql.container.createTmpOldTruncate) {
		return exports.truncateTempTablesMN(context, asyncDone);
	}

	statements = [
		context.sql.container.createTmpTruncate,
		context.sql.container.createTmpOldTruncate,
		context.sql.container.createPrincipalTruncate,
		context.sql.container.createDependentTruncate
	];

	return dataCollector.execTempTableStatements(statements, context, asyncDone);
};

/**
 * Executes deletion of temporary created tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.dropTempTables = function (context, asyncDone) {
	var statements;
	context.logger.silly('dataCollectorLinks', 'dropTempTables');

	// Special hack for $batch.
	// In batch we do not know at this place if we are in m2n mode or not.
	// If 'createTmpOldDrop' property exists than we are in m2n mode
	if (!context.sql.container.createTmpOldDrop) {
		return exports.dropTempTablesMN(context, asyncDone);
	}

	statements = [
		context.sql.container.createTmpDrop,
		context.sql.container.createTmpOldDrop,
		context.sql.container.createPrincipalDrop,
		context.sql.container.createDependentDrop
	];

	return dataCollector.execTempTableStatements(statements, context, asyncDone);
};
