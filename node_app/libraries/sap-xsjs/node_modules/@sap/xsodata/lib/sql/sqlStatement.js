'use strict';

var edm = require('./../utils/typedObjects');
var cloneContextWithNoAlias = edm.cloneContextWithNoAlias;
var InternalError = require('./../utils/errors/internalError');
var util = require('util');

/**
 * Create a new SqlBuildHanaContext
 * The buildContext is used as parameter for the toSqlHana functions
 * The buildContext stores whether null values are supported or not and
 * @param context
 * @constructor
 */
exports.SqlBuildHanaContext = function (context) {
    if (context) {
        this.oDataNullSupport = context.gModel.isNullSupported();
        var dbSeg = context.oData.dbSegmentLast;
        this.isNav = function (string) {
            return dbSeg._SelectedNavigations.indexOf(string) > -1;
        };
    } else {
        this.oDataNullSupport = false;
        this.isNav = false;
    }
    this.inOrderBy = false;
    this.table = null;
    this.noAlias = null; // only used in a cloned SqlBuildHanaContext to avoid using aliases in orderby clauses
};

exports.SqlBuildHanaContext.prototype.clone = function () {
    var c = new exports.SqlBuildHanaContext();
    c.oDataNullSupport = this.oDataNullSupport;
    c.isNav = this.isNav;
    c.table = this.table; // used in Property.prototype.toSqlHana
    c.noAlias = this.noAlias;
    c.inOrderBy = this.inOrderBy;
    return c;
};


exports.PostContainer = function PostContainer() {
    this.createTmp = null;
    this.insertTmp = null;
    this.insertReal = null;
    this.select = null;
};

exports.GetContainer = function GetContainer() {
    this.createTmp = null;
    this.insertTmp = null;
    this.selectTmp = null;
    //if there is no $expand or $count is set or $value is set
    this.select = null;
};

exports.GetContainerAll = function GetContainerAll() {
    this.createTmp = [];
    this.insertTmp = [];
    this.selectTmp = [];
    //if there is no $expand or $count is set or $value is set
    this.select = [];
};


exports.PutContainer = function PutContainer() {
    this.createTmpOld = null;
    this.createTmp = null;
    this.insertTmpOld = null;
    this.insertTmp = null;
    this.updateReal = null;
};


exports.DeleteContainer = function DeleteContainer() {
    this.createTmpDel = null;
    this.insertTmpDel = null;
    this.delete = null;
};

/**
 * @Class Eq
 * @constructor
 * @param left
 * @param right
 */
/*
 function Eq(left, right) {
 this.left = left;
 this.right = right;
 }
 exports.Eq = Eq;
 Eq.prototype.toSqlHana = function (context,parameter) {
 var ret = '';
 ret += '(' + this.left.toSqlHana(context,parameter) + ' = ' + this.right.toSqlHana(context,parameter) + ')';
 return ret;
 };*/

/**
 * @Class Value
 * @constructor
 * @param value
 */
function Value(value) {
    this.value = value;
}
exports.Value = Value;

Value.prototype.toSqlHana = function (context, parameter) {
    parameter.push(this.value);
    return '?';
};


/**
 * @class Exists
 * @constructor
 * @param select
 */
function Exists(select) {
    this.exists = select;
}
exports.Exists = Exists;

Exists.prototype.toSqlHana = function (context, parameter) {
    var ret = '';
    ret += 'exists (' + this.exists.toSqlHana(context, parameter) + ')';
    return ret;
};


/**
 * @class Property
 * @constructor
 * @param table
 * @param property
 * @param propertyType
 * @param alias
 */
function SelectProperty(table, property, propertyType, alias) {
    this.table = table;
    this.property = property;
    this.propertyType = propertyType;
    this.alias = alias;
}
exports.SelectProperty = SelectProperty;

SelectProperty.prototype.toSqlHana = function (context, parameter, withoutTable) {
    var sql = [];
    var conversionFunction;

    if (!context.inOrderBy) {
        conversionFunction = getConversionFunction(this.propertyType);
    }

    if (conversionFunction) {
        sql.push(conversionFunction, "(");
    }

    if (!withoutTable && this.table) {
        sql.push('"', this.table, '".');
    }
    sql.push('"', this.property, '"');

    if (conversionFunction) {
        sql.push(")");
    }

    if (!context.noAlias) {
        if (conversionFunction || this.alias) {
            sql.push(' "', (this.alias || this.property), '"');
        }
    }

    return sql.join("");
};

/**
 * Returns name of the SQL data type conversion function, which should be used in the SQL SELECT statement to retrieve
 * property with the specified <code>propertyType</code>.
 *
 * @param {string} propertyType - type of the property, for which the data type conversion function has to be determined
 * @returns {string} name of the data type conversion function or <code>undefined</code>, when no type conversion
 * should be applied.
 */
function getConversionFunction(propertyType) {
    if (propertyType === "DECIMAL") {
        return 'to_char';
    }
}

function AggregateSelectProperty(aggregation, table, property, aggregateAlias) {
    this.aggregation = aggregation;
    this.aggregateAlias = aggregateAlias;
    this.selectProperty = new SelectProperty(table, property);
    this.property = this.selectProperty.property;
    this.table = this.selectProperty.table;
}
exports.AggregateSelectProperty = AggregateSelectProperty;


AggregateSelectProperty.prototype.toSqlHana = function (context, parameters) {
    var sql = this.aggregation +
        '(' +
        this.selectProperty.toSqlHana(context, parameters) +
        ')';

    if (this.aggregateAlias) {
        sql += ' "' + this.aggregateAlias + '"';
    }

    return sql;
};

function ParameterSelectProperty(table, property, alias, value) {
    SelectProperty.call(this, table, property, null, alias);
    this.value = value;
}

ParameterSelectProperty.prototype.toSqlHana = function (context, parameter) {
    var _alias = this.alias || this.property;
    /*
     if(!_alias){
     if (!withoutTable && this.table) {
     _alias =  this.table + '.';
     }else{
     _alias = '';
     }
     _alias = this.property;
     }*/
    this.value.toSqlHana(context, parameter);
    return util.format('? "%s"', _alias);
};

exports.ParameterSelectProperty = ParameterSelectProperty;

function CreateProperty(property, type) {
    this.property = property;
    this.type = type;
}
exports.CreateProperty = CreateProperty;

CreateProperty.prototype.toSqlHana = function (/*context, parameter*/) {
    return '"' + this.property + '" ' + this.type;
};

/**
 * @class Formula
 * @constructor
 * @param {string} table
 * @param {string} formula
 * @param {string} alias
 */
function Formula(table, formula, alias) {
    this.table = table;
    this.formula = formula;
    this.alias = alias;

}
exports.Formula = Formula;

Formula.prototype.toSqlHana = function () {
    var ret = '';
    if (this.table) {
        ret += '"' + this.table + '".';
    }
    ret += this.formula;
    if (this.alias) {
        ret += ' "' + this.alias + '"';
    }
    return ret;
};


/**
 * @class Formula
 * @constructor
 * @param {string=} alias
 */
function OverFormula(alias) {
    this.alias = alias;
    this.orders = [];
}
exports.OverFormula = OverFormula;

OverFormula.prototype.addSortOrder = function (order) {
    this.orders.push(order);
};

OverFormula.prototype.addSortOrders = function (orders) {
    for (var i = 0; i < orders.length; i++) {
        this.orders.push(orders[i]);
    }
};


OverFormula.prototype.toSqlHana = function (context, parameter) {
    var clonedContext = null;
    var sql = '';
    sql += 'row_number() over(';

    var i;
    if (this.orders.length > 0) {

        clonedContext = cloneContextWithNoAlias(context);
        clonedContext.inOrderBy = true;
        sql += '\norder by ';
        for (i = 0; i < this.orders.length; i++) {
            sql += ( i === 0 ? '' : ', ');
            sql += this.orders[i].toSqlHana(clonedContext, parameter);
        }
        sql += '';
    }

    sql += ') ';

    sql += '"' + this.alias + '"';

    return sql;
};

/**
 * @class Create
 * @constructor
 */
function Create() {
    this.modifiers = [];
    this.table = null;
    this.as = null;
    this.postModifiers = null;
    this.properties = [];
}
exports.Create = Create;


Create.prototype.addProperties = function (properties) {
    this.properties = this.properties.concat(properties);
};

Create.prototype.addUniqueProperties = function (properties) {
    addUniqueSqlStatementsToList(properties, this.properties);
    return this;
};

Create.prototype.addProperty = function (property) {
    this.properties.push(property);
};

/**
 * Set modifiers
 * SQL: create <modifiers> table ... as
 * @param {Array.<String>} modifiers
 */
Create.prototype.setModifiers = function (modifiers) {
    this.modifiers = modifiers;
};


/**
 * Set post modifiers
 * SQL: create ... table ... as ... <postModifiers>
 * @param {Array.<String>} postModifiers
 */
Create.prototype.setPostModifiers = function (postModifiers) {
    this.postModifiers = postModifiers;
};

/**
 * Set Table
 * SQL: create ... table <table> as
 * @param table
 */
Create.prototype.setTableName = function (table) {
    this.table = table;
};

/**
 * Set As
 * SQL: create ... table ... as (<as>)
 * @param as
 */
Create.prototype.setAs = function (as) {
    this.as = as;
};

Create.prototype.toSqlHana = function (context, parameter) {
    var i;

    var sql = '';


    sql += 'create ';

    for (i = 0; i < this.modifiers.length; i++) {
        sql += ' ' + this.modifiers[i];
    }
    sql += '\ntable ';
    sql += '"' + this.table + '" ';
    if (this.as) {
        sql += '\nas ( ';
        sql += this.as.toSqlHana(context, parameter);
        sql += ') ';
    }

    if (this.properties.length > 0) {
        sql += '(';
        for (i = 0; i < this.properties.length; i++) {
            sql += ( i === 0 ? '' : ', ');
            sql += this.properties[i].toSqlHana(context, parameter);
        }
        sql += ')';
    }

    if (this.postModifiers) {
        for (i = 0; i < this.postModifiers.length; i++) {
            sql += ' ' + this.postModifiers[i];
        }
    }
    return sql;
};


/**
 * @class Insert
 * @constructor
 */
function Insert() {
    this.intoTable = null;
    this.subSelect = null;
    this.nv = [];
}
exports.Insert = Insert;


/**
 * Set Table
 * SQL: insert into <table>
 * @param {{table: String}} table
 */
Insert.prototype.setTableName = function (table) {
    this.intoTable = table;
};

/**
 * Set subSelect
 * SQL: insert into ... select <subselect>
 * @param {exports.Select} subSelect of type "Select"
 */
Insert.prototype.setSubSelect = function (subSelect) {
    this.subSelect = subSelect;
};

Insert.prototype.toSqlHana = function (context, parameter) {
    var sql = '';
    sql += 'insert into ';

    if (this.intoTable.table.substr(0, 1) === '#') {
        sql += ' "' + this.intoTable.table + '" ';
        if (this.intoTable.alias) {
            sql += ' as "' + this.intoTable.alias + '" ';
        }
    } else {
        if (this.intoTable.schema) {
            sql += '"' + this.intoTable.schema + '".';
        }

        sql += '"' + this.intoTable.table + '"';
        if (this.intoTable.alias) {
            sql += ' as "' + this.intoTable.alias + '" ';
        }
    }

    var i;
    var tmp = '';
    //sql += this.table + ' ';
    //collect names
    if (this.nv.length > 0) {
        for (i = 0; i < this.nv.length; i++) {
            tmp += ( tmp.length > 0 ? ', ' : '');
            tmp += this.nv[i].name.toSqlHana(context, parameter, true);
        }
        sql += '(' + tmp + ')';
    }

    if (this.subSelect) {
        sql += ' (';
        sql += ' ' + this.subSelect.toSqlHana(context, parameter);
        sql += ') ';
    } else {
        sql += ' values ';
        tmp = '';
        for (i = 0; i < this.nv.length; i++) {
            tmp += ( tmp.length > 0 ? ', ' : '');

            if (this.nv[i].value && this.nv[i].value.toSqlHana) {
                var xxx = [];
                this.nv[i].value.toSqlHana(context, xxx, true);

                //console.log('----toSqlHana-'+JSON.stringify(xxx[0]));
                tmp += this.nv[i].value.toSqlHana(context, parameter, true);
            } else {
                //console.log('--------------'+JSON.stringify(this.nv[i].value,null,4));
                tmp += '?';
                parameter.push(this.nv[i].value);
            }
        }
        sql += '(' + tmp + ')';
        //collect values
    }
    return sql;
};

/**
 * Add array of properties to be inserted
 * @param {(exports.Property)} names
 */
Insert.prototype.addNames = function (names) {
    for (var i = 0; i < names.length; i++) {
        var n = names[i];
        this.nv.push({
            name: n,
            value: undefined //null would be a valid OData value
        });
    }
};

Insert.prototype.setValue = function (name, value) {
    for (var i = 0; i < this.nv.length; i++) {
        var nv = this.nv[i];
        if (nv.name.property === name) {
            nv.value = value;
        }
    }
};


/**
 * @class Select
 * @constructor
 */
function Select() {
    this.select = [];
    this.from = { schema: null, table: null, alias: null };
    this.froms = [];
    this.joins = [];
    this.whereAnded = [];
    this.orders = [];
    this.groupBys = [];
    this.limit = null;
    this.offset = null;
    this.fallbackStatement = null;
    this.addCalcViewHint = false;
}
exports.Select = Select;

Select.prototype.addJoin = function (table, on) {
    this.joins.push({
        table: table,
        on: on
    });
};

Select.prototype.addJoinTable = function (select, on, alias) {
    this.joins.push({
        tableSelect: select,
        alias: alias,
        on: on
    });
};

Select.prototype.toSqlHana = function (context, parameter) {
    var i = 0;
    var clonedContext = null;

    var sql = '';
    sql += 'select ';

    for (i = 0; i < this.select.length; i++) {
        sql += ( i === 0 ? '' : ', ');
        sql += this.select[i].toSqlHana(context, parameter);
    }

    sql += '\nfrom ';

    sql += this.froms.map(function (from) {
        if (from.subQuery) {
            return '(' + from.subQuery.toSqlHana(context, parameter) + ')';
        }

        var fromString = '';
        if (from.table.substr(0, 1) !== '#' && from.schema) {
            fromString += '"' + from.schema + '".';
        }

        fromString += '"' + from.table + '"';

        if (from.placeholders) {
            var sql_placeholders = from.placeholders.map(function (ph) {
                return ph.toSqlHana(context, parameter);
            });
            fromString += '(';
            fromString += sql_placeholders.join(',');
            fromString += ')';
        }

        if (from.alias) {
            fromString += ' as "' + from.alias + '"';
        }

        return fromString;
    }).join(', ');

    this.joins.forEach(function (join) {
        if (join.table) {
            var table = join.table;
            sql += ' join ';
            if (table.schema) {
                sql += '"' + table.schema + '".';
            }
            sql += '"' + table.table + '"';
            if (table.alias) {
                sql += ' as "' + table.alias + '"';
            }

            if (join.on.length > 0) {
                sql += ' on ';
                for (i = 0; i < join.on.length; i++) {
                    sql += ( i === 0 ? '' : ' and ');
                    sql += join.on[i].toSqlHana(context, parameter);
                }
            }
        } else if (join.tableSelect) {
            sql += ' join (';
            sql += join.tableSelect.toSqlHana(context, parameter);
            sql += ' )';

            if (join.alias) {
                sql += ' "' + join.alias + '" ';
            }

            if (join.on.length > 0) {
                sql += ' on ';
                for (i = 0; i < join.on.length; i++) {
                    sql += ( i === 0 ? '' : ' and ');
                    sql += join.on[i].toSqlHana(context, parameter);
                }
            }
        }
    });

    if (this.whereAnded.length > 0) {
        sql += '\nwhere ';
        for (i = 0; i < this.whereAnded.length; i++) {
            sql += ( i === 0 ? '' : ' and ');
            sql += this.whereAnded[i].toSqlHana(context, parameter);
        }
    }

    if (this.groupBys.length > 0) {
        sql += '\ngroup by ';
        sql += this.groupBys.map(function (groupBy) {
            return groupBy.toSqlHana(context, parameter);
        }).join(', ');
        sql += ' ';
    }

    if (this.orders.length > 0) {

        clonedContext = cloneContextWithNoAlias(context);
        clonedContext.inOrderBy = true;

        sql += '\norder by  ';
        for (i = 0; i < this.orders.length; i++) {
            sql += ( i === 0 ? '' : ', ');
            sql += this.orders[i].toSqlHana(clonedContext, parameter);
        }
        sql += '';
    }

    if (this.limit !== null && this.limit >= 0 && this.offset) {
        sql += ' limit ? offset ?';
        parameter.push(this.limit);
        parameter.push(this.offset);
    } else if (this.offset) {
        sql += ' limit null offset ?';
        parameter.push(this.offset);
    } else if (this.limit !== null && this.limit >= 0) {
        sql += ' limit ?';
        parameter.push(this.limit);
    }

    if (this.addCalcViewHint) {
        sql += ' with hint (NO_CALC_VIEW_UNFOLDING)';//due to fix in calcview engine
    }
    return sql;
};

/**
 * Sets an indicator to add with "hint (NO_CALC_VIEW_UNFOLDING)" to the sql statment.
 */
Select.prototype.setAddCalcViewHint = function () {
    this.addCalcViewHint = true;
};

/**
 * Set from clause
 * SQL: select ... from <from>
 * @param {{schema: string, table: string, alias: string}} from qualified tablename or
 */
Select.prototype.setFrom = function (from) {
    return this.addFrom(from);
};

Select.prototype.addFrom = function (from, inputParams) {
    function addPlaceholder(kv) {
        from.placeholders = from.placeholders || [];
        from.placeholders.push({
                key: kv.key,
                value: kv.value,
                toSqlHana: function (context, params) {
                    var sql = util.format('placeholder."$$%s$$" => ?', kv.key);
                    var localParams = [];
                    var value;

                    if (kv.value instanceof edm.EdmString) {
                        //Edm.String
                        kv.value.toSqlHana(context, localParams);
                        value = localParams[0];
                        value = value.replace("\\", "\\\\");   // replace \ with \\
                        value = value.replace("'", "\\'");     // replace ' with \' prep. stm. adds 2nd '
                        params.push(value); //e.g. "'a string'"
                    }
                    else if (kv.value instanceof edm.Number) {
                        kv.value.toSqlHana(context, localParams);
                        if (typeof localParams[0] === "string") {
                            //Edm.Decimal(SMALLDECIMAL,DECIMAL),
                            params.push(localParams[0]); //e.g. "1.2"
                        } else {
                            //Edm.Byte(TINYINT), Edm.Int16(SMALLINT), Edm.Int32(INTEGER), Edm.Int64(BIGINT),
                            //Edm.Single(REAL,FLOAT), Edm.Double(DOUBLE)
                            params.push(localParams[0].toString()); //e.g. "1"
                        }
                    }
                    else if (kv.value instanceof edm.Binary) {
                        value = kv.value.value;
                        value = value.substring(2, value.length - 1);
                        params.push(value);
                        //params.push(kv.value.value);
                    } else if (kv.value instanceof edm.DateTime) {
                        //Edm.DateTime(DATE,SECONDDATE,TIMESTAMP)
                        kv.value.toSqlHana(context, localParams);
                        params.push(localParams[0]); //e.g. "'1753-01-01'","'1753-01-01'","'1753-01-01'"
                    } else if (kv.value instanceof edm.Time) {
                        //Edm.Time(TIME)
                        kv.value.toSqlHana(context, localParams);
                        params.push(localParams[0]); //e.g. "'00:00:00'"
                    } else {
                        throw new InternalError('Navigation to calc view expected after an Input path segment');
                    }


                    //
                    //kv.value
                    return sql;
                }
            }
        );
    }

//http://saphanatutorial.com/sap-hana-variables-and-input-parameters/
    if (inputParams) {
        inputParams.forEach(addPlaceholder);
    }
    this.froms.push(from);
    return this;
}
;

/**
 * Set from clause
 * SQL: select ... from <from>
 * @param {exports.Select} from qualified tablename or
 * @param {string} [alias] qualified tablename or
 */
Select.prototype.setFromBySubQuery = function (from, alias) {
    this.froms.push({ subQuery: from, alias: alias });
    return this;
};


/**
 * Set array of selected properties
 * @param {(exports.Property|exports.Formula)[]} select
 */
Select.prototype.setSelect = function (select) {
    this.select = select;
};

/**
 * Add array of selected properties
 * @param {(exports.Property|exports.Formula)[]} select
 */
Select.prototype.addSelect = function (select) {
    this.select = this.select.concat(select);
    return this;
};

Select.prototype.addSelects = function (select) {
    this.select = this.select.concat(select);
    return this;
};

Select.prototype.addUniqueSelects = function (selects) {
    addUniqueSqlStatementsToList(selects, this.select);
    return this;
};


/**
 *
 * @param {{key : exports.Property, value: string}[]} keyValuePairs
 */
Select.prototype.addWhereKeyValuePairs = function (keyValuePairs) {
    for (var i = 0; i < keyValuePairs.length; i++) {
        var kv = keyValuePairs[i];
        this.whereAnded.push(new edm.BinaryOperator(edm.EQ, kv.key, kv.value, true /*strict*/));
    }
    return this;
};


/**
 * @param {(edm.BinaryOperator|Object)} expression
 */
Select.prototype.addWhereAnded = function (expression) {
    this.whereAnded.push(expression);
    return this;
};

/**
 * @param {edm.SortOrder[]} orders
 */
Select.prototype.addSortOrders = function (orders) {

    for (var i = 0; i < orders.length; i++) {
        this.orders.push(orders[i]);
    }
    return this;
};

Select.prototype.addGroupBys = function (groupBys) {

    this.groupBys = this.groupBys.concat(groupBys);

    return this;
};

Select.prototype.addSortOrder = function (order) {

    this.orders.push(order);
    return this;
};

/**
 *
 * @param {edm.OrderBy} orderBy
 */
Select.prototype.addOrderBy = function (orderBy) {
    for (var i = 0; i < orderBy.orders.length; i++) {
        this.orders.push(orderBy.orders[i]);
    }
    return this;
};

/**
 *
 * @param {edm.OrderBy} offset
 */
Select.prototype.addOffset = function (offset) {
    this.offset = offset;
    return this;
};

/**
 *
 * @param {edm.OrderBy} limit
 */
Select.prototype.addLimit = function (limit) {
    this.limit = limit;
    return this;
};

Select.prototype.toString = function () {
    return this.toSqlHana({}, []);
};

Select.prototype.addFallbackStatement = function (statement) {
    this.fallbackStatement = statement;
};

Select.prototype.getFallbackStatement = function () {
    return this.fallbackStatement;
};

function Update() {
    this.update = { schema: null, table: null, alias: null };
    this.from = { schema: null, table: null, alias: null };
    this.copyFromTo = [];//list of SelectProperty
    this.whereAnded = [];
}
exports.Update = Update;

/**
 * Set from clause
 * SQL: select ... from <from>
 * @param {{schema: string, table: string, alias: string}} table from qualified tablename
 */
Update.prototype.setTable = function (table) {
    this.update = table;
};

Update.prototype.setFrom = function (from) {
    this.from = from;
};

Update.prototype.addSetCopyProperties = function (properties, fromAlias) {
    var max = properties.length;

    var p;
    for (var i = 0; i < max; i++) {
        p = {
            from: new SelectProperty(fromAlias, properties[i].property, null),
            to: properties[i]
        };
        this.copyFromTo.push(p);
    }
};


Update.prototype.addWhereKeyValuePairs = function (keyValuePairs) {
    for (var i = 0; i < keyValuePairs.length; i++) {
        var kv = keyValuePairs[i];
        this.whereAnded.push(new edm.BinaryOperator(edm.EQ, kv.key, kv.value, true /*strict*/));
    }
};


Update.prototype.toSqlHana = function (context, parameter) {
    var i;

    var sql = '';
    sql += 'update ';

    if (this.update.table.substr(0, 1) === '#') {
        sql += ' "' + this.update.table + '" ';
        if (this.update.alias) {
            sql += ' "' + this.update.alias + '"';
        }
    } else {
        if (this.update.schema) {
            sql += '"' + this.update.schema + '".';
        }

        sql += '"' + this.update.table + '"';
        if (this.update.alias) {
            sql += ' "' + this.update.alias + '"';
        }
    }

    sql += ' set ';

    for (i = 0; i < this.copyFromTo.length; i++) {
        var cft = this.copyFromTo[i];
        sql += ( i === 0 ? '' : ', ');

        sql += cft.to.toSqlHana(context, parameter, true);
        sql += '=';

        sql += cft.from.toSqlHana(context, parameter);
    }

    // from <origin table> <origin alias> , <temp table> <temp alias>
    sql += '\nfrom ';
    if (this.update.schema) {
        sql += '"' + this.update.schema + '".';
    }
    sql += ' "' + this.update.table + '" ';
    if (this.update.alias) {
        sql += ' "' + this.update.alias + '"';
    }

    if (this.from.table.substr(0, 1) === '#') {
        sql += ' , ';
        sql += ' "' + this.from.table + '" ';
        if (this.from.alias) {
            sql += ' "' + this.from.alias + '"';
        }
    } else {
        if (this.from.schema) {
            sql += '"' + this.from.schema + '".';
        }

        sql += '"' + this.from.table + '"';
        if (this.from.alias) {
            sql += ' "' + this.from.alias + '"';
        }
    }

    if (this.whereAnded.length > 0) {
        sql += '\n where ';
        for (i = 0; i < this.whereAnded.length; i++) {
            sql += ( i === 0 ? '' : ' and ');
            sql += '(';
            sql += this.whereAnded[i].toSqlHana(context, parameter);
            sql += ')';
        }
    }

    return sql;
};

/**
 * @class Upsert
 * @constructor
 */
function Upsert() {
    this.upsert = { schema: null, table: null, alias: null };
    this.subSelect = null;
    this.nv = [];
    this.whereAnded = [];
}
exports.Upsert = Upsert;

Upsert.prototype.setTable = function (table) {
    this.upsert = table;
};

Upsert.prototype.setSubSelect = function (subSelect) {
    this.subSelect = subSelect;
};

Upsert.prototype.addNames = function (names) {
    for (var i = 0; i < names.length; i++) {
        var n = names[i];
        this.nv.push({
            name: n,
            value: undefined //null would be a valid OData value
        });
    }
};

Upsert.prototype.setValue = function (name, value) {
    for (var i = 0; i < this.nv.length; i++) {
        var nv = this.nv[i];
        if (nv.name.property === name) {
            nv.value = value;
        }
    }
};

Upsert.prototype.addWhereKeyValuePairs = function (keyValuePairs) {
    for (var i = 0; i < keyValuePairs.length; i++) {
        var kv = keyValuePairs[i];
        this.whereAnded.push(new edm.BinaryOperator(edm.EQ, kv.key, kv.value, true /*strict*/));
    }
};


Upsert.prototype.toSqlHana = function (context, parameter) {
    var i;

    var sql = '';
    sql += 'upsert ';

    if (this.upsert.table.substr(0, 1) === '#') {
        sql += ' "' + this.upsert.table + '" ';
        if (this.upsert.alias) {
            sql += ' "' + this.upsert.alias + '"';
        }
    } else {
        if (this.upsert.schema) {
            sql += '"' + this.upsert.schema + '".';
        }

        sql += '"' + this.upsert.table + '"';
        if (this.upsert.alias) {
            sql += ' "' + this.upsert.alias + '"';
        }
    }

    var tmp = '';
    if (this.subSelect) {
        //sql += ' (';
        sql += ' ' + this.subSelect.toSqlHana(context, parameter);
        //sql += ') ';
    } else {
        sql += ' values ';
        tmp = '';
        for (i = 0; i < this.nv.length; i++) {
            tmp += ( tmp.length > 0 ? ', ' : '');

            if (this.nv[i].value && this.nv[i].value.toSqlHana) {
                var xxx = [];
                this.nv[i].value.toSqlHana(context, xxx, true);

                //console.log('----toSqlHana-'+JSON.stringify(xxx[0]));
                tmp += this.nv[i].value.toSqlHana(context, parameter, true);
            } else {
                //console.log('--------------'+JSON.stringify(this.nv[i].value,null,4));
                tmp += '?';
                parameter.push(this.nv[i].value);
            }
        }
        sql += '(' + tmp + ')';
        //collect values
    }

    if (this.whereAnded.length > 0) {
        sql += '\n where ';
        for (i = 0; i < this.whereAnded.length; i++) {
            sql += ( i === 0 ? '' : ' and ');
            sql += '(';
            sql += this.whereAnded[i].toSqlHana(context, parameter);
            sql += ')';
        }
    }

    return sql;
};

/*------------------------------*/

/**
 * Creates following structure on given target object:
 *
 * target.table: {
 *   name: nameParameter,
 *   schema: schemaParameter,
 *}
 *
 *@param {Object} target The target object to create structure on
 *@param {String} tableName The table name
 *@param {String} [schema] The name of the schema
 *@throws {Error} throws an error if tableName was not provided
 *@private
 */
function initializeDDLObject(target, tableName, schema) {
    if (!tableName) {
        throw new Error("Can not create object without 'tableName' parameter");
    }

    target.table = {
        name: tableName,
        schema: schema
    };
}

/**
 * Creates a simple prefixed sql like '<prefix> TABLE "schema"."table"'.
 *
 *@param {Object} options Options object with following structure:
 *       {prefix:..., schema: ..., table: ...} where schema is optional
 *@private
 */
function buildSimplePrefixedSql(options) {
    var sql = options.prefix + " TABLE ";
    if (options.schema) {
        sql += '"' + options.schema + '".';
    }
    sql += '"' + options.table + '"';
    return sql;
}

/**
 * Creates a drop table sql statement object.
 *
 *@param {string} tableName The table name to drop
 *@param {string} [schema] The name of the schema
 */
function Drop(tableName, schema) {
    initializeDDLObject(this, tableName, schema);
}

exports.Drop = Drop;

/**
 * Creates the correspondig hana drop sql statement string which is represented by this object.
 *
 *@returns {string} The generated sql string
 */
Drop.prototype.toSqlHana = function () {
    return buildSimplePrefixedSql({
        prefix: "DROP",
        schema: this.table.schema,
        table: this.table.name
    });
};


/**
 * Creates a truncate table sql statement object.
 *
 *@param {string} tableName The table name to truncate
 *@param {string} [schema] The name of the schema
 */
function Truncate(tableName, schema) {
    initializeDDLObject(this, tableName, schema);
}

exports.Truncate = Truncate;


/**
 * Creates the correspondig hana truncate sql statement string which is represented by this object.
 *
 *@returns {string} The generated sql string
 */
Truncate.prototype.toSqlHana = function () {
    return buildSimplePrefixedSql({
        prefix: "TRUNCATE",
        schema: this.table.schema,
        table: this.table.name
    });
};


/*------------------------------*/
function Delete() {
    this.from = { schema: null, table: null, alias: null };
    this.whereAnded = [];
}
exports.Delete = Delete;


Delete.prototype.setFrom = function (from) {
    this.from = from;
};


Delete.prototype.addWhereKeyValuePairs = function (keyValuePairs) {
    for (var i = 0; i < keyValuePairs.length; i++) {
        var kv = keyValuePairs[i];
        this.whereAnded.push(new edm.BinaryOperator(edm.EQ, kv.key, kv.value, true /*strict*/));
    }
};

Delete.prototype.toSqlHana = function (context, parameter) {
    var i = 0;

    var sql = '';
    sql += 'delete ';

    sql += 'from ';

    if (this.from.table.substr(0, 1) === '#') {
        sql += '' + this.from.table + '';
        if (this.from.alias) {
            sql += ' as "' + this.from.alias + '"';
        }
    } else {
        if (this.from.schema) {
            sql += '"' + this.from.schema + '".';
        }

        sql += '"' + this.from.table + '"';
        if (this.from.alias) {
            sql += ' as "' + this.from.alias + '"';
        }
    }


    if (this.whereAnded.length > 0) {
        sql += '\n where ';
        for (i = 0; i < this.whereAnded.length; i++) {
            sql += ( i === 0 ? '' : ' and ');
            sql += this.whereAnded[i].toSqlHana(context, parameter);
        }
    }

    return sql;
};

function addUniqueSqlStatementsToList(newStatements, list) {

    newStatements = [].concat(newStatements);

    newStatements.forEach(function (newStatement) {
        if (list.every(notEqual.bind(null, newStatement))) {
            list.push(newStatement);
        }
    });

    function notEqual(prop, current) {
        return prop.toSqlHana({}, []) !== current.toSqlHana({}, []);
    }
}

exports._addETagToSelect = addETagToSelect;

/**
 * Adds ETag generation expression to the SQL SELECT statement as an pseudo "__etag" column in the result set.
 * @param {object} dbSegment - DBSegment, which represents entity type of the entity, for which ETag should be generated
 * @param {object} selectStmt - SQL SELECT statement, where the ETag expression should be added to the SELECT part
 * @param {string} [tableAlias] - DB table alias. The parameter should be specified only if the alias of the table,
 *  which is used in the SELECT statement is different than the Alias property of the DBSegment (i.e. default alias).
 */
function addETagToSelect(dbSegment, selectStmt, tableAlias) {
    var concurrentProperties = dbSegment.entityType.getConcurrentProperties(),
        hashFunctionArguments,
        eTagExpression;

    tableAlias = tableAlias || dbSegment.getAlias();

    hashFunctionArguments = concurrentProperties.map(function (property) {
        var dbColumnName = util.format('"%s"."%s"', tableAlias, property);
        return util.format("ifnull(to_binary(%s), to_binary('')), case when %s is null then '01' else '00' end",
            dbColumnName, dbColumnName);
    });

    eTagExpression = "to_varchar(hash_sha256(" + hashFunctionArguments.join(",") + "))";
    selectStmt.addSelects(new Formula(null, eTagExpression, "__etag"));
}

exports.createSelectStmtForETag = createSelectStmtForETag;

/**
 * Creates SELECT statement to generate ETag for the entity.
 *
 * @param {object} dbSegment - DBSegment, which represents the entity type of the entity, for which ETag should be
 *  generated.
 * @returns {Select}
 */
function createSelectStmtForETag(dbSegment) {
    var selectStmt = new Select();

    addETagToSelect(dbSegment, selectStmt);
    selectStmt.addFrom(dbSegment.getAliasedTableName());
    selectStmt.addWhereKeyValuePairs(dbSegment.getQKeyWithValues());

    return selectStmt;
}

/**
 * Builds table statement object. The type of object created depends on the type parameter.
 * Currently supported is Truncate, Drop.
 * Examples:
 * <code>
 * var sql = require("lib/.../sqlStatement");
 * var truncate = sql.buildTableStatement(sql.Truncate, sqlContext, "yourTableName");
 * var drop = sql.buildTableStatement(sql.Drop, sqlContext, "yourTableName");
 * </code>
 *
 *@param  type {Function} The type of statement you wnat to create
 *@param  sqlContext {Object} The current sql context
 *@param  tableName {String} The name of the table to operate on
 *@returns {Object} Object representation of sql statement
 */
function buildTableStatement(type, sqlContext, tableName) {
    sqlContext.context.logger.debug('sqlStatement', 'buildTableStatement');
    if (type === exports.Truncate) {
        return new exports.Truncate(tableName, sqlContext.context.defaultSchema);
    }
    if (type === exports.Drop) {
        return new exports.Drop(tableName, sqlContext.context.defaultSchema);
    }
    return null;
}
exports.buildTableStatement = buildTableStatement;


/**
 * Object representing the DB table column in the SQL query (except of the SELECT queries, where SelectProperty class
 * should be used).
 * @param {string} table - DB table name
 * @param {string} property - DB column name
 * @param {string} alias - alias, which should be used for the DB column in the SQL query
 * @constructor
 */
function TableColumn(table, property, alias) {
    this.table = table;
    this.property = property;
    this.alias = alias;
}
exports.TableColumn = TableColumn;

TableColumn.prototype.toSqlHana = function (context, parameter, withoutTable) {
    var sql = [];

    if (!withoutTable && this.table) {
        sql.push('"', this.table, '".');
    }
    sql.push('"', this.property, '"');

    if (this.alias) {
        sql.push(' "', this.alias, '"');
    }
    return sql.join("");
};
