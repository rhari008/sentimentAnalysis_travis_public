'use strict';

var async = require('async');

//contexts
var NetworkContext = require('./utils/networkContext');
var RequestContext = require('./utils/requestContext');

//processing steps
var db = require('./db/connect');
var uriParser = require('./http/uriParser');
var xsodataFileReader = require('./model/xsodataReader');
var metadataDbReader = require('./model/metadataReader');
var oDataUriParser = require('./uri/oDataUriParser');
var uriChecks = require('./uri/checks');
var applyUriChecks = require('./uri/applyChecks');
var oDataProcessor = require('./processor/processor');
var errorProcessor = require('./processor/errorProcessor');
var ConditionalHttpHandler = require('./http/conditionalHttpHandler');
var httpRequestValidator = require('./http/validator/httpRequestValidator');
var authorizationProcessor = require('./processor/authorizationProcessor');
var dataCollector = require('./sql/dataCollector');


//Tools
var Logger = require('./utils/logger');
var configuration = require('./configuration');
var handlerConfiguration = require('./handlerConfiguration');
var JsonSerializer = require('./serializer/jsonSerializer').JsonSerializer;

var simpleRequest = require('./http/simpleHttpRequest');
var simpleResponse = require('./http/simpleHttpResponse');
var utils = require('./utils/utils');

var debugView = require('./utils/debugView');
var Measurement = require('./utils/measurement');

//Errors
var TestError = require('./utils/errors/testError');
var HttpErrorDebugInfo = require('./utils/errors/debugInfo');
var InternalError = require('./utils/errors/internalError');


exports.testExits = {
    afterConnectDb: 1,
    afterPrepareUri: 2,
    afterReadService: 3,
    afterLoadMetadata: 4,
    afterParseODataUri: 5,
    beforeProcess: 6,
    afterProcess: 7,
    beforeSendHandler: 8
};

exports.ODataHandler = function (handlerOptions) {
    this.logger = new Logger(handlerOptions.logger);

    this.handlerConfiguration = new handlerConfiguration.HandlerConfiguration(handlerOptions);
    this.handlerConfiguration.setLogger(this.logger);

    this.modelData = {};
    this._registeredCallBacks = {};
    this._metadataReader = metadataDbReader;
};


exports.ODataHandler.prototype.register = function (step, callBack) {
    this._registeredCallBacks[step] = callBack;
};

function checkRegisteredSteps(handler, step, err, context, asyncDone) {
    try {
        var done = function (err) {
            if (err) {
                handler.logger.debug('xsodata', 'Developer exit "' + step + '" returned with error:');
                handler.logger.debug('xsodata', err.message);
                return asyncDone(err, context);
            }
            handler.logger.debug('xsodata', 'Developer exit "' + step + '" returned');
            return asyncDone(err, context);
        };

        if (handler._registeredCallBacks[step]) {
            handler.logger.debug('xsodata', 'Developer exit "' + step + '" called');
            return handler._registeredCallBacks[step](err, context, done);
        } else {
            return asyncDone(null, context);
        }
    } catch (ex) {
        return asyncDone(ex, context);
    }
}


/**
 * Create an Array containing all functions used to process the OData request. The array is use to feed the async.waterfall method.
 * @returns { Array }
 */
exports.ODataHandler.prototype.createRequestChain = function (context) {
    var ret;
    if (Measurement.isActive()) {
        ret = [
            utils.injectContext(context),

            utils.tryAndMeasure(uriParser.prepareUri, 'prepareUri'),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterPrepareUri, null),

            utils.tryAndMeasure(httpRequestValidator.validate, 'validateHttpRequest'),

            //utils.tryAndMeasure(db.connect, 'dbConnect'),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterConnectDb, null),

            utils.try(debugView.checkParameter),

            utils.tryAndMeasure(xsodataFileReader.loadXsodataConfiguration, 'loadXsodataConfiguration'),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterReadService, null),

            utils.tryAndMeasure(this._metadataReader.loadModelMetadata, 'loadModelMetadata'),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterLoadMetadata, null),

            utils.tryAndMeasure(oDataUriParser.parseODataUri, 'parseODataUri'),

            utils.tryAndMeasure(authorizationProcessor.processAuthorization, 'processAuthorization'),

            Measurement.measureAsync(applyUriChecks.bind(null, uriChecks), 'applyUriChecks'),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterParseODataUri, null),

            utils.try(checkRegisteredSteps, this, exports.testExits.beforeProcess, null),

            utils.tryAndMeasure(ConditionalHttpHandler.processConditionalRequest, 'processConditionalRequest'),

            utils.tryAndMeasure(oDataProcessor.processRequest, 'processRequest'),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterProcess, null)
        ];
    } else {
        ret = [
            utils.injectContext(context),

            utils.try(uriParser.prepareUri),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterPrepareUri, null),

            utils.try(httpRequestValidator.validate),

            //utils.try(db.connect),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterConnectDb, null),

            utils.try(debugView.checkParameter),

            utils.try(xsodataFileReader.loadXsodataConfiguration),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterReadService, null),

            utils.try(this._metadataReader.loadModelMetadata),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterLoadMetadata, null),

            utils.try(oDataUriParser.parseODataUri),

            utils.try(authorizationProcessor.processAuthorization),

            applyUriChecks.bind(null, uriChecks),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterParseODataUri, null),

            utils.try(checkRegisteredSteps, this, exports.testExits.beforeProcess, null),

            utils.try(ConditionalHttpHandler.processConditionalRequest),

            utils.try(oDataProcessor.processRequest),

            utils.try(checkRegisteredSteps, this, exports.testExits.afterProcess, null)
        ];
    }

    return ret;
};

/**
 * Processes a OData request
 * @param request
 * @param response
 * @param { module:configuration.RequestOptions } requestOptions @see module:configuration.RequestOptions
 * @param applicationDone Callback call after request is processed. Signature ( err : Object, context : Object )
 */
exports.ODataHandler.prototype.processRequest = function process(request, response, requestOptions, applicationDone) {
    var networkContext;
    var context;
    var baseMeasurement;

    try {
        networkContext = new NetworkContext(this.handlerConfiguration, requestOptions);
        context = new RequestContext(networkContext, requestOptions || {});

        // Create the truncate/drop containers for temp tables.
        // We collect all create temp table statements here and check,
        // in case of an error, if all tables have been truncated/deleted
        // This check will be done in saveExit(...) method.
        context.networkContext.cleanSessionTruncateContainer = [];
        context.networkContext.cleanSessionDropContainer = [];

        context.logger.info('xsodata', 'process url: ' + request.url);

        context.request = simpleRequest.createRequest(request, context.uriPrefix);
        context.response = simpleResponse.createResponse();
        context.httpResponse = response;
        context.modelData = this.modelData; //inject model into context

        //Start measurement if sap-ds-debug is inside URL (rough check)
        if (request.url.search('sap-ds-debug') > 0) {
            Measurement.setActive(true);

            context.measurements = [];

            baseMeasurement = new Measurement('ODataHandler.processRequest', true);

            context.measurements.push(baseMeasurement);
        }

        context.isAuthorized = true;

        async.waterfall(
            this.createRequestChain(context),
            function (err) {
                if (Measurement.isActive()) {
                    baseMeasurement.counterStop();
                    Measurement.setActive(false);
                }
                exports.assertCleanTempTables(context, function (error, context) {
                    return this.saveExit(error || err, context, applicationDone);
                }.bind(this));
            }.bind(this)
        );
    } catch (exception) {
        var err = new InternalError('InternalError', context, exception);
        exports.assertCleanTempTables(context, function (error, context) {
            return this.saveExit(error || err, context, applicationDone);
        }.bind(this));
    }
};


exports.ODataHandler.prototype.saveExit = function (err, context, applicationDone) {
    try {
        if (err) {

            //check for special test case which test internal state
            if (context.mode === configuration.modes.development) {
                if (err instanceof TestError) {
                    context.logger.debug('xsodata', 'dev mode: is TestError');
                    if (applicationDone) {
                        return applicationDone(err, context);
                    }
                }
            }

            //render debug info to response
            if (err instanceof HttpErrorDebugInfo) {
                var serializer = new JsonSerializer(context, 65536, 200);
                serializer.write(err.message);
                serializer.flush();
            } else {
                //normal error processing write error to response
                errorProcessor.process(context, err);
            }
        }

        //cleanup
        db.disconnect(context);

    } catch (ex) {
        //don't kill client

        context.logger.debug('xsodata', 'ERROR ODATA: ' + err);
        context.logger.debug('xsodata', 'ERROR in Error Handling : ' + ex);

        if (applicationDone) {
            applicationDone(err, context);
        } else {
            context.logger.error('xsodata', 'ERROR ODATA: ' + err);
            context.logger.error('xsodata', 'ERROR in Error Handling : ' + ex);
        }
    }

    return this.finish(null, context, applicationDone);
};

exports.ODataHandler.prototype.finish = function (err, context, applicationDone) {
    context.logger.silly('xsodata', 'finish');

    return checkRegisteredSteps(this, exports.testExits.beforeSendHandler, err, context, function (err, context) {
        var rTo = context.httpResponse;
        var rFrom = context.response;

        if (context.debugView && context.isAuthorized === true) {
            debugView.writeDebugInfo(context, rFrom, rTo);
        } else {
            rTo.writeHead(rFrom.statusCode || 500, rFrom.headers || {});
            rTo.write(rFrom.data);
        }

        rTo.end();

        if (applicationDone) {
            return applicationDone(err, context);
        } else {
            if (err) {
                throw err;
            }
        }
    });
};

/**
 * The next callback to be called when processing is finished
 * 
 * @callback Next
 * @param {Error|null} error An error if any occured before. Cann be null
 * @param {Object} context The odata context
 */

/**
 * Assert existing temp table statements. If there are still existing temp table
 * statements we have to clean up the session before we exist.
 * 
 * @param {Object} context The odata context
 * @param {Next} next The callback to be called when finish processing
 */
exports.assertCleanTempTables = function assertCleanTempTables(context, next) {
    var statements, statementStr;

    context.logger.info('xsodata', 'assertCleanTempTables');

    statements = context.networkContext.cleanSessionTruncateContainer
        .concat(context.networkContext.cleanSessionDropContainer);

    if (statements.length > 0) {

        statementStr = JSON.stringify(statements, null, 2);
        context.logger.info('xsodata', 'assertCleanTempTables - remaining temp tables found: ' + statementStr);
        context.logger.info('xsodata', 'assertCleanTempTables - starting clean up remaining temp tables');

        dataCollector.execTempTableStatements(statements, context, function done(err) {
            next(err, context);
        });
    } else {
        next(null, context);
    }

};
